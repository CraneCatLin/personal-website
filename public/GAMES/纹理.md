参考[[纹理贴图]]  
  
顶点法线：对该顶点相邻面的法线作加权平均，得到该顶点处法线  
右手系下，逆时针方向，边叉乘是向外  
  
  
三维纹理展开至二维uv坐标系，约定范围均为$[0,1]$  
  
对三角形顶点设置纹理，然后插值得到每个像素位置的该项值  
  
  
## 重心坐标  
平面上一三角形ABC，任意一点$P(x,y)$  
$$  
\begin{gather}  
(x,y)=\alpha A + \beta B + \gamma C \\  
若\alpha + \beta + \gamma =1，则该P点在\triangle ABC所在平面上\\  
记(\alpha , \beta ,\gamma)为重心坐标\\  
当三个值均大于等于0时，点在三角形内部\\ \\  
与面积关系：\\  
\alpha = \frac{S_A}{S_A + S_B + S_C}\\  
\beta = \frac{S_B}{S_A + S_B + S_C}\\  
\gamma = \frac{S_C}{S_A + S_B + S_C}\\ \\  
S_{\triangle}=\frac{1}{2}||\mathbf{u}\times \mathbf{v}||\\  
利用上式可求面积或者重心坐标  
\end{gather}  
$$  
重心坐标可以作为属性插值的系数  
重心坐标在投影时可能发生变化，因此要在对应三维/二维空间内求对应重心坐标  
#todo   
``` c++  
auto [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);  
float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());  
float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();  
zp *= Z;  
```  
  
## 双线性插值  
![双线性插值| 200](双线性插值.png )  
  
$$  
\begin{gather}  
一维线性插值：\\  
\text{lerp}(x, v_0, v_1) = v_0 + x(v_1 - v_0)\\ \\ \\  
双线性插值：如上图\\  
u_0 = {lerp}(s, u_{00}, u_{10}) \\  
u_1 = {lerp}(s, u_{01}, u_{11}) \\  
\\  
f(x, y) = \text{lerp}(t, u_0, u_1)  
  
  
\end{gather}  
$$  
  
目的是求$(x,y)$处值，结合最近四点(Bilinear)插值获取。  
用于texel少于pixel时扩大纹理。  
同理也可以先取近处16点，四个一组插值，再对四个插值结果二次插值，即Bicubic。  
（每次二维插值需要四个点，Bicubic等价于二重二维插值）  
  
  
## Mipmap  
texel多于pixel时  
用于快速获取某处平均值，仅用于正方形  
![纹理映射_mipmap| 400](纹理映射_mipmap.png )  
$$  
\begin{gather}  
L = \max\left(   
  \sqrt{\left( \frac{\partial u}{\partial x} \right)^2 + \left( \frac{\partial v}{\partial x} \right)^2},   
  \sqrt{\left( \frac{\partial u}{\partial y} \right)^2 + \left( \frac{\partial v}{\partial y} \right)^2}   
\right)\\ \\  
D=log_2 L  
\end{gather}  
$$  
即pixel映射到纹理坐标系之后，对应正方形大小（即采样区域）。  
  
Mipmap事先处理过图片，即每次四个texel为一组进行平均，每次边长减半，直至只剩一个texel。保存过程中每一张图。  
在这种情况下，D就代表了需要从原始纹理向上查询几张图可以找到pixel映射正方形范围内的平均值，即这个映射正方形在Mipmap该层级的图上仅覆盖一个texel。  
若D不为整数，则查询上下两层对应处的值，然后插值。  
  
## 各向异性过滤  
即将Mipmap的正方形换成矩形区域  
解决了矩形查询的问题。  